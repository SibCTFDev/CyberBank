# Разбор уязвимостей сервиса SibirCTF

Всем привет!

На **SibirCTF** вам удалось порешать сервис, разработанный нашей командой.  
Сервис представлял из себя **Биржу по покупке кибервалюты**, где можно было создавать, покупать и продавать продукты. 

В качестве секретной информации использовался контент в продукте, который сохранялся в закодированном виде. Чтобы просмотреть контент, нужно было владеть продуктом. То есть если продукт принадлежит вам, то происходло декодирование контента. 

Поэтому для получения флага можно было:
- накопить достаточно денег и купить продукт с флагом
- получить содержимое продукта с флагом через уязвимость контроля доступа
- декодировать значение контента, разобравшись с криптографией

Рассмотрим эти способы:

---

### 1. Накрутка баланса за счет нескольких аккаунтов

Чтобы получить флаг, можно было купить продукт с флагом. Чтобы накопить достаточно денег, можно было создать несколько пользователей и, покупая продукты одного пользователя, собирать у него деньги.

---

### 2. Уязвимость с нулевым балансом

Уязвимость позволяет бесплатно покупать продукт, если его цена равна остатку баланса. То есть если купить продукт на все деньги, то деньги не отнимутся. Это происходит из-за условия в функции `updateUser`, которое проверяет, нужно ли обновлять баланс:
```
if (param.balance) user.balance = param.balance;
```
Если после покупки обновленный баланс нулевой, то баланс юзера не обновляется. Таким образом, можно использовать две учетки для быстрой накрутки баланса, после чего купить продукт с флагом.

---

### 3. Цепочка уязвимостей: ReDoS → Race Condition

Самая интересная уязвимость — вы могли в коде увидеть регулярное выражение, которое должно было вас смутить и натолкнуть на мысль, что разработчики заложили в сервис **ReDoS**:
```
if (/^REASON: (([a-z])+.)+\s#([0-9])+$/.test(buyInfo.reason))
```
Регулярное выражение находилось в функции покупки продукта. Оно проверяло параметр `reason` в запросе на покупку. 

Если проверить его в специализированном сервисе, можно было сразу получить пэйлоад:

![alt text](images/regex.png)

Внимательно изучив код, можно было заметить, что проверка наличия достаточных средств на балансе происходит до валидации `reason`. Однако обновление баланса юзера просиходит после анализа регулярки:

![alt text](images/regex-code.png)

Поэтому, если сначала отправить запрос, вызывающий DoS:

![alt text](images/dos-req.png)

То во время обработки регулярки можно отправить еще несколько запросов на покупку продуктов, которые успешно выполнятся, потому что пройдут проверку условия `(user.balance < product.price)`:

![alt text](images/dos-req-2.png)

Например, у юзера было на балансе 300$:

![alt text](images/dos-balance.png)

И есть два продукта в магазине:

![alt text](images/dos-2-products.png)

Выполнив последовательность запросов, описанную выше, юзер получит оба продукта на аккаунт, заплатив только за один:

![alt text](images/dos-result.png)

---

### 4. Незащищенная база данных

База данных торчит наружу:

![alt text](images/database.png)

Достаточно подключиться к ней и изменить `ownerId` продукта с флагом на свой, или пополнить баланс своего пользователя чтобы купить нужный продукт, или снизить цену на продукт с флагом, да что угодно!

![alt text](images/database-hack.png)

---

### 5. Уязвимость отсутствия контроля доступа в WS

Если обратить внимание, как приложение получает данные о продуктах, то можно заметить определенный WS-запрос:

![alt text](images/ws-request.png)

Запрос содержит json `{"uid":1,"pid":null}`, изучив его внимательно, становится понятно, что параметр `uid` отвечает за идентификатор юзера, а параметр `pid` - за идентификатор продукта. Если передать `"pid":null`, то возвращаются все продукты.

При этом в декодированном виде приходит контент тех продуктов, идентификатор владельца которых передан в `uid` в запросе. Таким образом, можно отправить повторный запрос с `pid` владельца продукта с флагом, и в ответе получить декодированный контент:   

![alt text](images/ws-hack.png)

---

### 6. Фейковая криптография и обфускация

Если внимательно прочитать код сервиса, можно заметить, что криптография, которой шифровались данные сервиса — на самом деле **и не криптография вовсе**:  

![alt text](images/strong-crypto.png)

Наверное, вас должна была напугать обфускация программного кода, но на самом деле, так как это **TypeScript**, можно было легко декодировать данные, просто перенеся код из функции `verifyContent` в сплойт или исполнив его в интерпретаторе TS:

![alt text](images/decode.png)

---

### 7) Скрытый флаг внутри изображения

Следующей проблемой стал алгоритм генерации картинки — так как алгоритм прятал внутри изображения флаг, вы могли парсить картинки и извлекать из них содержимое:

![alt text](images/image-flag-inside.png)
