# Разбор уязвимостей сервиса SibirCTF

Всем привет!

На **SibirCTF** вам удалось порешать сервис, разработанный нашей командой.  
Сервис представлял из себя **Биржу по покупке кибервалюты**.

При создании продукта его контент сохранялся в закодированном виде. Чтобы просмотреть контент, нужно было купить продукт. То есть если продукт принадлежит вам, то происходло декодирование контента. 

Поэтому для получения флага можно было:
- накопить достаточно денег и купить продукт с флагом
- получить содержимое продукта с флагом через уязвимость контроля доступа
- декодировать значение контента, разобравшись с криптографией

Рассмотрим все способы:

---

### 1. Накрутка баланса за счет нескольких аккаунтов

Чтобы получить флаг, можно было купить продукт с флагом. Чтобы накопить достаточно денег, можно было создать несколько пользователей и, покупая продукты одного пользователя, собирать у него деньги.

---

### 2. Уязвимость с нулевым балансом

Уязвимость позволяет бесплатно покупать продукт, если его цена равна остатку баланса. То есть если купить продукт на все деньги, то деньги не отнимутся. Это происходит из-за условия в функции `updateUser`, которое проверяет, нужно ли обновлять баланс:
```
if (param.balance) user.balance = param.balance;
```
Если после покупки обновленный баланс нулевой, то баланс юзера не обновляется. Таким образом, можно использовать две учетки для быстрой накрутки баланса, после чего купить продукт с флагом.

---

### 3) Цепочка уязвимостей: ReDoS → Race Condition

Самая интересная уязвимость — вы могли в коде увидеть регулярное выражение, которое должно было вас смутить и натолкнуть на мысль, что разработчики заложили в сервис **ReDoS**.  
И это правда, но на самом деле — это была **цепочка уязвимостей**:

```
ReDoS → Race Condition
```
---

### 4. Уязвимость отсутствия контроля доступа в WS

Если обратить внимание, как приложение получает данные о продуктах, то можно заметить определенный WS-запрос:

![image](https://github.com/user-attachments/assets/6938b0a3-de72-454e-99dd-4697a006dab7)

Запрос содержит json `{"uid":1,"pid":null}`, изучив его внимательно, становится понятно, что параметр `uid` отвечает за идентификатор юзера, а параметр `pid` - за идентификатор продукта. Если передать `"pid":null`, то возвращаются все продукты.

При этом в декодированном виде приходит контент тех продуктов, идентификатор владельца которых передан в `uid` в запросе. Таким образом, можно отправить повторный запрос с `pid` владельца продукта с флагом, и в ответе получить декодированный контент:   

![image](https://github.com/user-attachments/assets/e277068b-d9a7-46e3-9b5f-3c34c9497335)

---

### 5. Фейковая криптография и обфускация

Если внимательно прочитать код сервиса, можно заметить, что криптография, которой шифровались данные сервиса — на самом деле **и не криптография вовсе**:  

![image](https://github.com/user-attachments/assets/ca864f38-c7a9-43e4-847b-3d22edcb2ebb)

Наверное, вас должна была напугать обфускация программного кода, но на самом деле, так как это **TypeScript**, можно было легко декодировать данные, просто перенеся код из функции `verifyContent` в сплойт или исполнив его в интерпретаторе TS:

![image](https://github.com/user-attachments/assets/c0000150-e9b4-4daf-8949-1c53af42316e)

---

### 6) Скрытый флаг внутри изображения

Следующей проблемой стал алгоритм генерации картинки — так как алгоритм прятал внутри изображения флаг, вы могли парсить картинки и извлекать из них содержимое:

![alt text](images/image-flag-inside.png)


---

### Финальная карта уязвимостей

В результате у нас получилась вот такая карта недостатков в сервисе:

![alt text](images/final-vuln-map.png)
